# So sánh và lựa chọn công nghệ vẽ topo
## 1. So sánh các công nghệ vẽ topology

Bảng so sánh một số thư viện/framework phổ biến cho việc vẽ và quản lý sơ đồ (topology diagram, flow chart, graph editor):

| Công nghệ| Loại| Ưu điểm| Nhược điểm| Trường hợp dùng tốt nhất|
|-|-|-|-|-|
| **React Flow** | React library | - Tích hợp chặt với React (state, props, hook).<br>- API rõ ràng, dễ mở rộng.<br>- Nhiều tính năng sẵn: zoom/pan, drag-drop node, custom node/edge, mini-map, background grid.<br>- Quản lý state topo theo React state → dễ đồng bộ backend.<br>- Tài liệu tốt. | - Phụ thuộc vào React.<br>- Không mạnh về vẽ graph lớn hàng nghìn node (hiệu năng giảm). | Ứng dụng web dùng React, cần interactive diagram, custom node/edge, dễ tích hợp logic. |
| **Dagre / dagre-d3** | JS library (thuần) | - Tự động layout node theo DAG.<br>- Nhỏ gọn, dễ nhúng.<br>- Có thể kết hợp với D3.js để vẽ. | - Không có UI drag-drop sẵn.<br>- Cần tự code nhiều khi muốn tương tác cao.<br>- Chỉ tối ưu cho đồ thị có hướng. | Khi chỉ cần layout topo tự động, ít tương tác. |
| **GoJS** | JS library (framework-agnostic) | - Tính năng cực nhiều (layout, animation, undo/redo, link routing, grouping…).<br>- Hiệu năng khá tốt.<br>- Dễ export ảnh/PDF. | - Thương mại (chỉ bản trial miễn phí).<br>- API phức tạp, learning curve cao.<br>- Không phải React-first. | Dự án thương mại cần rất nhiều tính năng vẽ chuyên sâu. |
| **Cytoscape.js**| JS library (thuần) | - Hiệu năng tốt cho graph lớn.<br>- Nhiều layout có sẵn.<br>- API mạnh cho graph manipulation.<br>- Có thể dùng với bất kỳ framework nào. | - UI mặc định ít thân thiện.<br>- Custom node UI phức tạp hơn React Flow. | Khi cần xử lý graph lớn, thuật toán layout, phân tích mạng. |
| **D3.js** | JS visualization library | - Tự do tuyệt đối về vẽ SVG/Canvas.<br>- Nhiều thuật toán layout.<br>- Hiệu năng cao. | - Không có UI topo sẵn, phải code hầu hết logic tương tác.<br>- Learning curve cao. | Khi cần toàn quyền kiểm soát render và animation, vẽ nhiều loại biểu đồ. |
---

## 2. Lý do chọn React Flow cho dự án

**Dùng React cho frontend**  
- React Flow viết cho React, tận dụng state, props, hooks → Dễ tích hợp với logic React hiện tại.
- Không cần wrapper phức tạp như khi dùng Cytoscape.js hay GoJS.

**Cần tương tác cao**
- Drag & drop node, kết nối edge, zoom/pan mượt.
- Tích hợp mini-map, background grid sẵn.
- Tự định nghĩa node/edge với HTML/JSX (ví dụ: node hiển thị icon, text, nút bấm).

**Dễ đồng bộ với backend**
- Mọi thay đổi (thêm node, xóa edge, di chuyển) đều là event React → Gửi lên API lưu topology dễ dàng.

**Dễ tùy biến UI**
- Node có thể chứa bất kỳ component React nào.
- Edge custom (ví dụ: step, smoothstep, bezier, conditional edge).

**Tài liệu và cộng đồng tốt**
- Tài liệu rõ ràng, nhiều ví dụ.
- Cộng đồng React dev hay dùng → dễ hỏi/tra cứu.

**Hiệu năng đủ tốt cho topology vừa và nhỏ**
- Dự án topo mạng, sơ đồ hệ thống, luồng dữ liệu tầm vài trăm node vẫn mượt.

# Thiết kế Database cho dự án

## 1. Các bảng chính

### 1.1. `node_type` – loại node
Lưu loại phần tử trong topology (service, load balancer, server, DB).

| Trường          | Kiểu dữ liệu | Mô tả |
|-----------------|-------------|-------|
| `type_id` (PK)  | INT         | ID loại node |
| `type_name`     | VARCHAR(50) | Tên loại (Service, Load balancer, Module, Server, Database) |
| `icon`          | VARCHAR(255) | Icon url để hiển thị trên giao diện |
| `description`   | TEXT        | Mô tả loại node |
---

### 1.2. `node` – thông tin node
Đại diện cho một thành phần trong topology.

| Trường          | Kiểu dữ liệu | Mô tả |
|-----------------|-------------|-------|
| `node_id` (PK)  | INT         | ID node |
| `name`          | VARCHAR(100) | Tên node |
| `type_id` (FK)  | INT         | Loại node (liên kết `node_type`) |
| `status`        | ENUM('normal','warning','error') | Trạng thái hiện tại, trường này giúp FE hiển thị nhanh tình trạng node mà ko phải truy vấn bảng alert |
| `ip_address`    | VARCHAR(45)| Địa chỉ IP (IPv4 hoặc IPv6) |
| `pid`           | INT | Process ID để phân biệt các tiến trình trên cùng IP|
| `port`          | INT | Cổng mà process đang lắng nghe (nếu có) |
| `last_update`   | DATETIME    | Thời điểm cập nhật trạng thái |
| `details`       | JSON/TEXT   | Thông tin chi tiết node (CPU, RAM, dịch vụ chạy…) |
---

### 1.3. `edge` – quan hệ giữa các node
Xác định kết nối vật lý hoặc logic giữa các phần tử.

| Trường           | Kiểu dữ liệu | Mô tả |
|------------------|-------------|-------|
| `edge_id` (PK)   | INT         | ID quan hệ |
| `source_id` (FK) | INT         | Node nguồn |
| `target_id` (FK) | INT         | Node đích |
| `description`    | TEXT        | Mô tả quan hệ |

---

### 1.4. `alert` – lưu cảnh báo
Mỗi khi node phát sinh cảnh báo.

| Trường         | Kiểu dữ liệu | Mô tả |
|----------------|-------------|-------|
| `alert_id` (PK)| INT         | ID cảnh báo |
| `node_id` (FK) | INT         | Node phát sinh cảnh báo |
| `severity`     | ENUM('low','medium','high','critical') | Mức độ cảnh báo |
| `message`      | TEXT        | Nội dung cảnh báo |
| `timestamp`    | DATETIME    | Thời điểm phát sinh |
| `resolved`     | BOOLEAN     | Đã xử lý hay chưa |

---

### 1.5. `fault_path` – đường lỗi
Lưu các fault path đã phát hiện.

| Trường             | Kiểu dữ liệu | Mô tả |
|--------------------|-------------|-------|
| `path_id` (PK)     | INT         | ID đường lỗi |
| `root_cause_id` (FK) | INT       | Node gốc gây lỗi |
| `affected_node_id` (FK) | INT    | Node bị ảnh hưởng |
| `timestamp`        | DATETIME   | Thời điểm ghi nhận |

---

## 2. Quan hệ giữa các bảng

```plaintext
node_type (1) --- (N) node
node (1) --- (N) edge (node.source_id & node.target_id)
node (1) --- (N) alert
node (1) --- (N) fault_path.root_cause_id
node (1) --- (N) fault_path.affected_node_id
```

---

## 3. Điểm cần lưu ý khi dựng DB
- **Real-time update**: Cần có cột `last_update` và cơ chế trigger hoặc job để đồng bộ với frontend (WebSocket).
- **Hiệu năng**: Nếu topology lớn, nên cache dữ liệu node/edge bằng Redis để frontend vẽ nhanh hơn.
- **Mở rộng**: Dùng `JSON` cho `details` để linh hoạt thêm thông tin mà không phải sửa schema.
